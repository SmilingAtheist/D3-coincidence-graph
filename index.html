<!DOCTYPE html>
<html>
<head>
    <!-- <script type="text/javascript" src="../d3/d3.js"></script> -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>
        .nodes text {
          font-family: sans-serif;
          font-size: 15px;
          fill: blue;
        }
    </style>
</head>
<body>
    <div>
        <label>Enter the word:
            <input id="word" type="text">
        </label>
        <button id="buttonAdd" type="button">Add</button>
        <button id="buttonRemove" type="button">Remove</button>
    </div>
    <script type="text/javascript"> 

        // full dataset loaded form csv files 
        var fullDataset = {edges: [] , nodes: []};
        // subset of fullDataset chosen to visulize
        var dataset = {edges: [] , nodes: []};
        // key function for binding nodes to data
        var key = function(d) {
            return d.word;
        };

        //Width and height
        var width = 1000;       
        var height = 600;

        var transitionTime = 500;
        var baseOpacity = 0.8;

        opacityScale = d3.scalePow()
            .exponent(0.1)
            .domain([1,10])
            .range([0, 1]);
        fontSizeScale = d3.scalePow()
            .exponent(0.38)
            .domain([0,1])
            .range([0, 50]);

        // handling button clicks
        document.getElementById("buttonAdd").addEventListener("click", addWord);
        document.getElementById("buttonRemove").addEventListener("click", removeWord);

        // Creating svg
        var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        svg.append("text")
            .attr("id", "message")
            .attr("x", 0)
            .attr("y", 15)
            .text("loading the data...");

        // Adding svg objects to nodes of the graph 
        var svg_nodes = svg.append("g")
            .attr("class", "nodes")
            .selectAll("text")
            .data(dataset.nodes, key)
            .enter()
            .append("text")
            .text(function(d) {
                return d.word;
            })
            .style('font-size', function(d) {return fontSizeScale(d.freq)})
             //Handling events: mouseover, mouseout, dragging
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .call(d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded));

        // Adding forces to the simulation:
        var simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id( function(d) { return d.word; } )
                .distance(0) 
                // similiar words are attracting each other
                .strength( function(edge) { 
                    return 0.05 * edge.pRatio; 
                }))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("charge", d3.forceManyBody()
                .strength(-400));
       
        simulation
            .nodes(dataset.nodes)
            .on("tick", ticked)
            .alpha(100)
            .alphaTarget(0)
            .alphaDecay(0.1);
       
        // loading the data and adding some starting words 
        d3.csv("nodes.csv", function(error1, data1) { d3.csv("edges.csv", function(error2, data2) {

            if(error1 || error2) {
                svg.select("#message").text("failed to load the data");
            }

            fullDataset.nodes = data1;
            fullDataset.edges = data2;

            //data successfulyy loaded
            svg.select("#message").text("");

            addWord("girl");
            addWord("young");
            addWord("robot");
            addWord("boy");
            addWord("magic");
            addWord("student");
            addWord("school");
            addWord("powers");
            addWord("kingdom");
            addWord("right");
            addWord("village");
            addWord("earth");
            addWord("monster");
            addWord("feelings");
            addWord("and");
            addWord("who");
            addWord("giant");
            addWord("vampire");
            addWord("blood");
            addWord("ship");
            addWord("crew");
            addWord("king");
            addWord("sword");
        })});


        // defining functions
        function ticked() {
            svg_nodes
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });
        }

        function dragStarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragEnded(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function mouseover(d1) {
            var edge;
            svg_nodes
                .transition()
                .duration(transitionTime)
                .style("opacity", function (d2) {
                    edge = getEdgeLinking(d1, d2);
                    if (edge === "same node") {
                        return 1;
                    } else if (!edge) {
                        return 0;    
                    } else if (edge.pRatio >= 1) {
                        return opacityScale(edge.pRatio);
                    } else if (edge.pRatio < 1) {
                        return opacityScale(1/edge.pRatio);
                    }
                })
                .style("fill", function (d2) {
                    edge = getEdgeLinking(d1, d2);
                    if (edge === "same node") {
                        return "black";
                    } else if (!edge) {
                        return "yellow";
                    } else if (edge.pRatio >= 1) {
                        return "green";
                    } else if (edge.pRatio < 1) {
                        return "red";
                    }                    
                });
        }

        function mouseout(d) {
            svg_nodes.transition()
                .duration(transitionTime)
                .style("opacity", baseOpacity)
                .style("fill", "blue");
        }

        function addWord(w) {
            // updating nodes
            var word = '';
            var alreadyAdded = false;
            // reading the word from input field
            if (document.getElementById("word").value) {
                w = document.getElementById("word").value;
            };
            // finding corresponding object in the full dataset
            for (var i = 0; i < fullDataset.nodes.length; i++) {
                if (fullDataset.nodes[i].word === w)
                    word = fullDataset.nodes[i];
            };
            // checking whether this word is already added
            for (var i = 0; i < dataset.nodes.length; i++) {
                if (dataset.nodes[i].word === w)
                    alreadyAdded = true;
            };
            //adding new word or outputing an error message
            if (!word) {
                svg.select("#message").text("wrong word");
                return null;
            } else if (alreadyAdded) {
                svg.select("#message").text("word already added");
                return null;
            }
            else {
                svg.select("#message").text("");
                dataset.nodes.push(word);
            }

            //updating edges
            var edge;
            var sourceInSubset;
            var targetInSubset;
            for (var i = 0; i < fullDataset.edges.length; i++) {
                edge = fullDataset.edges[i];
                sourceInSubset = false;
                targetInSubset = false;
                for (var j = 0; j < dataset.nodes.length; j++) {
                    switch(dataset.nodes[j].word) {
                        case edge.source:
                            sourceInSubset = true
                            break;
                        case edge.target:
                            targetInSubset = true
                            break;
                    }
                }
                if (sourceInSubset && targetInSubset) {
                    dataset.edges.push(edge);
                };
            };

            //updating svg objects bound to nodes
            var svg_nodes2 = svg.select("g.nodes").selectAll("text").data(dataset.nodes, key); //svg_nodes.data(dataset.nodes);
            svg_nodes2.enter().append("text")
                .text(function(d) {return d.word})
                .style('font-size', function(d) {return fontSizeScale(d.freq)})
                .style("opacity", "baseOpacity");
            svg_nodes = svg.select("g.nodes").selectAll("text");

            //repeating that we want to listen to events
            svg_nodes 
                .on("mouseover", mouseover)
                .on("mouseout", mouseout)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));

            //updating the simulation
            simulation.nodes(dataset.nodes);
            simulation.force("link").links(dataset.edges);
            simulation
                .alpha(0.3)
                .alphaTarget(0)
                .alphaDecay(0.05)
                .restart();
        };

        function removeWord(w) {
            var word_index = null;
            // reading the word from input field
            if (document.getElementById("word").value) {
                w = document.getElementById("word").value;
            };
            // finding corresponding object in the dataset
            for (var i = 0; i < dataset.nodes.length; i++) {
                if (dataset.nodes[i].word === w)
                    word_index = i;
            };
            //removing the word or outputing an error message
            if (!word_index) {
                svg.select("#message").text("word already removed or never there");
                return null;
            }
            else {
                svg.select("#message").text("");
                dataset.nodes.splice(word_index,1);
            };

            for (var i = 0; i < dataset.edges.length; i++) {
                if (dataset.edges[i].source === w || dataset.edges[i].target === w)
                    dataset.edges.splice(i,1);
            };
            //updating svg objects bound to nodes
            var svg_nodes2 = svg.select("g.nodes").selectAll("text").data(dataset.nodes, key);
            svg_nodes2.exit().remove()
            svg_nodes = svg.select("g.nodes").selectAll("text");

            svg_nodes 
                .on("mouseover", mouseover)
                .on("mouseout", mouseout)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));

            //updating the simulation
            simulation.nodes(dataset.nodes);
            simulation.force("link").links(dataset.edges);
            simulation
                .alpha(0.3)
                .alphaTarget(0)
                .alphaDecay(0.05)
                .restart();
        };

        function getEdgeLinking(node1, node2) {
            var edge;
            if (node1 === node2) {
                return "same node";
            } else {
                for (var i = 0; i < dataset.edges.length; i++) {
                    edge = dataset.edges[i];
                    if ((edge.target === node1 && edge.source === node2) || (edge.source === node1 && edge.target === node2)) {
                        return edge;
                    }
                }
                return null;
            }
        }
    </script>
</body>
</html>