<!DOCTYPE html>
<html>
<head>
    <script type="text/javascript" src="../d3/d3.js"></script>
    <style>
        .links line {
          stroke: red;
        }

        .nodes text {
          font-family: sans-serif;
          font-size: 15px;
          fill: blue;
        }
    </style>
</head>
<body>
    <div>
        <label>Enter the word:
        <input id="word" type="text">
        </label>
        <button id="buttonAdd" type="button">Add</button>
        <button id="buttonRemove" type="button">Remove</button>
    </div>
    <script type="text/javascript"> 
    // full dataset loaded form csv files 
    var fullDataset = {};
    // subset of fullDataset chosen to visulize
    var dataset = {edges: [] , nodes: []};
    //Width and height
    var width = 1000;       
    var height = 600;

    var transitionTime = 1000;

    document.getElementById("buttonAdd").addEventListener("click", addWord);
    document.getElementById("buttonRemove").addEventListener("click", removeWord);
    // Creating svg
    var svg = d3.select("body")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    var svg_nodes = svg.append("g")
        .attr("class", "nodes")
        .selectAll("text")
        .data(dataset.nodes)
        .enter()
        .append("text")
        .text(function(d) {
            return d.word;
        });
    // Adding forces to the simulation
    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink()
            .id( function(d) { return d.word; } )
            .distance(100))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));
    simulation
        .nodes(dataset.nodes)
        .on("tick", ticked);
       
    d3.csv("nodes.csv", function(data1) { d3.csv("edges.csv", function(data2) {

            fullDataset.nodes = data1;
            fullDataset.edges = data2;

            // Adding svg objects to nodes of the graph        
            //var svg_nodes = svg.append("g")
            //    .attr("class", "nodes")
            //    .selectAll("text")
            //    .data(dataset.nodes)
            //    .enter()
            //    .append("text")
            //    .text(function(d) {
            //        return d.word;
            //})
            //// Handling events: mouseover, mouseout, dragging
            //    .on("mouseover", mouseover)
            //    .on("mouseout", mouseout)
            //    .call(d3.drag()
            //        .on("start", dragStarted)
            //        .on("drag", dragged)
            //        .on("end", dragEnded));
        
            // Adding nodes to the simulation and running the simulation (handing ticks)

            addWord("girl");
            addWord("young");
        })});



        function ticked() {
            //link
            //    .attr("x1", function(d) { return d.source.x; })
            //    .attr("y1", function(d) { return d.source.y; })
            //    .attr("x2", function(d) { return d.target.x; })
            //    .attr("y2", function(d) { return d.target.y; });

            console.log('a');

            svg_nodes
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });
        }

        function dragStarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragEnded(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function mouseover(d,i) {
            svg_nodes.transition()
            .duration(transitionTime)
            .style("opacity", function (d2) {
                var edge;
                if (d === d2) {
                    return 1;
                } else {
                    for (var i = 0; i < dataset.edges.length; i++) {
                        edge = dataset.edges[i];
                        if ((edge.target === d && edge.source === d2) || (edge.source === d && edge.target === d2)) {
                            return edge.pRatio*0.5;
                        }
                    }
                    return 0;
                }
            });
        }

        function mouseout(d,i) {
            svg_nodes.transition()
                .duration(transitionTime)
                .style("opacity", 0.8);
        };

        function addWord(w) {
            // updating nodes
            if (document.getElementById("word").value.length > 0) {
                w = document.getElementById("word").value;
            };
            
            for (var i = 0; i < fullDataset.nodes.length; i++) {
                if (fullDataset.nodes[i].word === w)
                    word = fullDataset.nodes[i];
            };
            dataset.nodes.push(word);
            //updating edges
            var edge;
            var sourceInSubset;
            var targetInSubset;
            for (var i = 0; i < fullDataset.edges.length; i++) {
                edge = fullDataset.edges[i];
                sourceInSubset = false;
                targetInSubset = false;
                for (var j = 0; j < dataset.nodes.length; j++) {
                    switch(dataset.nodes[j].word) {
                        case edge.source:
                            sourceInSubset = true
                            break;
                        case edge.target:
                            targetInSubset = true
                            break;
                    }
                }
                if (sourceInSubset && targetInSubset) {
                    console.log(edge);
                    dataset.edges.push(edge);
                };
            };
            
            
            //console.log(word.word);
            //console.log(dataset.nodes);
            
           
            //updating svg objects bound to nodes
            var svg_nodes2 = svg.select("g.nodes").selectAll("text").data(dataset.nodes); //svg_nodes.data(dataset.nodes);
            svg_nodes2.enter().append("text").text(function(d) {return d.word});
            svg_nodes = svg.select("g.nodes").selectAll("text");

            // repeating that we want to listen to events
            svg_nodes 
                .on("mouseover", mouseover)
                .on("mouseout", mouseout)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));
            
            //updatings the simulation
            simulation.nodes(dataset.nodes);
            simulation.force("link").links(dataset.edges);
        };

        function removeWord() {
            var word = document.getElementById("word").value;
        };
    </script>
</body>
</html>